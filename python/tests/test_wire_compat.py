#!/usr/bin/env python3
"""Wire compatibility tests.

These tests verify that bytes generated by one implementation can be
correctly parsed by another. This is critical for cross-language interop.
"""

import subprocess
import os
import pytest

from vibedds.cdr import CdrSerializer, CdrDeserializer, ParameterListBuilder, encapsulation_header, PL_CDR_LE
from vibedds.types import (
    GuidPrefix, EntityId, Guid, SequenceNumber, Locator, Timestamp, Duration,
    ProtocolVersion, VendorId,
)
from vibedds.constants import (
    PID_PROTOCOL_VERSION, PID_VENDORID, PID_PARTICIPANT_GUID,
    PID_PARTICIPANT_LEASE_DURATION, PID_DEFAULT_UNICAST_LOCATOR,
    PID_METATRAFFIC_UNICAST_LOCATOR, PID_BUILTIN_ENDPOINT_SET,
    PID_TOPIC_NAME, PID_TYPE_NAME, PID_RELIABILITY, PID_DURABILITY,
    PID_ENDPOINT_GUID,
    ENTITYID_SPDP_BUILTIN_PARTICIPANT_WRITER, ENTITYID_PARTICIPANT,
    ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER,
)
from vibedds.wire import RtpsMessageBuilder
from vibedds.spdp import SPDPWriter
from vibedds.qos import serialize_reliability_qos, serialize_durability_qos, QosPolicy, ReliabilityKind


class TestKnownBytesSPDP:
    """Test SPDP message parsing with known byte sequences."""

    def test_python_spdp_known_bytes(self):
        """Generate SPDP bytes and verify structure."""
        prefix = GuidPrefix(bytes([0xAA, 0xBB, 0xCC, 0xDD, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]))
        writer = SPDPWriter(
            guid_prefix=prefix,
            local_ip="192.168.1.100",
            metatraffic_unicast_port=7410,
            user_unicast_port=7401,
        )
        data = writer.build_announcement()

        # Verify RTPS header
        assert data[:4] == b'RTPS', "RTPS magic"
        assert data[4] == 2, "Version major"
        assert data[5] == 5, "Version minor"
        assert data[6:8] == bytes([0xFF, 0x01]), "Vendor ID"
        assert data[8:20] == prefix.value, "GUID prefix"

        # Store for cross-language testing
        return data

    def test_spdp_roundtrip_bytes(self):
        """SPDP bytes should roundtrip through serialization."""
        from vibedds.spdp import SPDPReader

        prefix = GuidPrefix(bytes([0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC]))
        writer = SPDPWriter(
            guid_prefix=prefix,
            local_ip="10.0.0.1",
            metatraffic_unicast_port=7412,
            user_unicast_port=7403,
        )
        data = writer.build_announcement()

        # Parse it back
        participant = SPDPReader.parse_announcement(data)
        assert participant is not None
        assert participant.guid_prefix == prefix
        assert participant.protocol_version.major == 2
        assert participant.protocol_version.minor == 5
        assert participant.vendor_id.vendor == (0xFF, 0x01)


class TestKnownBytesSEDP:
    """Test SEDP message parsing with known byte sequences."""

    def test_sedp_endpoint_data_format(self):
        """Generate SEDP endpoint data and verify structure."""
        prefix = GuidPrefix(bytes([0xAA] * 12))
        endpoint_guid = Guid(prefix, EntityId(bytes([0x00, 0x00, 0x01, 0x02])))

        # Build parameter list for endpoint
        pl = ParameterListBuilder()

        # PID_ENDPOINT_GUID
        pl.add_parameter(PID_ENDPOINT_GUID, endpoint_guid.to_bytes())

        # PID_TOPIC_NAME
        ser = CdrSerializer()
        ser.write_string("HelloWorld")
        pl.add_parameter(PID_TOPIC_NAME, ser.getvalue())

        # PID_TYPE_NAME
        ser = CdrSerializer()
        ser.write_string("HelloWorld::HelloWorld")
        pl.add_parameter(PID_TYPE_NAME, ser.getvalue())

        # PID_RELIABILITY
        qos = QosPolicy(reliability=ReliabilityKind.RELIABLE)
        pl.add_parameter(PID_RELIABILITY, serialize_reliability_qos(qos))

        # PID_DURABILITY
        pl.add_parameter(PID_DURABILITY, serialize_durability_qos(qos))

        data = pl.finalize()

        # Verify it starts with parameters and ends with sentinel
        assert len(data) > 20, "Should have parameters"
        # Last 4 bytes should be PID_SENTINEL (0x0001) + length (0x0000)
        assert data[-4:-2] == bytes([0x01, 0x00]), "PID_SENTINEL"
        assert data[-2:] == bytes([0x00, 0x00]), "Sentinel length"

        return data

    def test_sedp_data_submessage_format(self):
        """Generate complete SEDP DATA submessage."""
        prefix = GuidPrefix(bytes([0xBB] * 12))
        dest_prefix = GuidPrefix(bytes([0xCC] * 12))

        # Build endpoint announcement
        endpoint_guid = Guid(prefix, EntityId(bytes([0x00, 0x00, 0x01, 0x02])))
        pl = ParameterListBuilder()
        pl.add_parameter(PID_ENDPOINT_GUID, endpoint_guid.to_bytes())
        ser = CdrSerializer()
        ser.write_string("TestTopic")
        pl.add_parameter(PID_TOPIC_NAME, ser.getvalue())
        ser = CdrSerializer()
        ser.write_string("TestType")
        pl.add_parameter(PID_TYPE_NAME, ser.getvalue())
        payload = encapsulation_header(PL_CDR_LE) + pl.finalize()

        # Build RTPS message
        builder = RtpsMessageBuilder(prefix)
        builder.add_info_ts(Timestamp.from_seconds(1000.0))
        builder.add_info_dst(dest_prefix)
        builder.add_data(
            reader_id=EntityId(bytes([0x00, 0x00, 0x03, 0xC7])),  # SEDP pubs reader
            writer_id=EntityId(bytes([0x00, 0x00, 0x03, 0xC2])),  # SEDP pubs writer
            writer_sn=SequenceNumber.from_value(1),
            serialized_payload=payload,
        )

        data = builder.build()

        # Verify RTPS header
        assert data[:4] == b'RTPS'
        assert len(data) > 50, "Should have submessages"

        return data


class TestKnownBytesHeartbeat:
    """Test HEARTBEAT message format."""

    def test_heartbeat_format(self):
        """Generate HEARTBEAT and verify structure."""
        prefix = GuidPrefix(bytes([0xDD] * 12))

        builder = RtpsMessageBuilder(prefix)
        builder.add_heartbeat(
            reader_id=EntityId(bytes([0x00, 0x00, 0x03, 0xC7])),
            writer_id=EntityId(bytes([0x00, 0x00, 0x03, 0xC2])),
            first_sn=SequenceNumber.from_value(1),
            last_sn=SequenceNumber.from_value(10),
            count=5,
        )

        data = builder.build()

        # RTPS header (20) + submessage header (4) + heartbeat body (28)
        assert len(data) == 20 + 4 + 28, f"Expected 52 bytes, got {len(data)}"

        return data


class TestKnownBytesAckNack:
    """Test ACKNACK message format."""

    def test_acknack_format(self):
        """Generate ACKNACK and verify structure."""
        from vibedds.types import SequenceNumberSet

        prefix = GuidPrefix(bytes([0xEE] * 12))

        # Create sequence number set with some missing
        sn_set = SequenceNumberSet(
            base=SequenceNumber.from_value(5),
            num_bits=32,
            bitmap=[0b11000000_00000000_00000000_00000000],  # Missing 5, 6
        )

        builder = RtpsMessageBuilder(prefix)
        builder.add_acknack(
            reader_id=EntityId(bytes([0x00, 0x00, 0x03, 0xC7])),
            writer_id=EntityId(bytes([0x00, 0x00, 0x03, 0xC2])),
            reader_sn_state=sn_set,
            count=1,
        )

        data = builder.build()
        assert len(data) > 20, "Should have submessage"

        return data


class TestCDRKnownBytes:
    """Test CDR encoding with known byte sequences."""

    def test_uint32_le_bytes(self):
        """uint32 little-endian encoding."""
        ser = CdrSerializer(endian="<")
        ser.write_uint32(0x12345678)
        assert ser.getvalue() == bytes([0x78, 0x56, 0x34, 0x12])

    def test_uint32_be_bytes(self):
        """uint32 big-endian encoding."""
        ser = CdrSerializer(endian=">")
        ser.write_uint32(0x12345678)
        assert ser.getvalue() == bytes([0x12, 0x34, 0x56, 0x78])

    def test_string_cdr_format(self):
        """String CDR encoding: length (including NUL) + chars + NUL.

        Note: CDR strings do NOT include trailing padding. Padding is only
        added when the NEXT field requires alignment.
        """
        ser = CdrSerializer()
        ser.write_string("Hi")
        data = ser.getvalue()
        # Length = 3 (H, i, NUL), then chars + NUL = 7 bytes total
        assert data[:4] == bytes([0x03, 0x00, 0x00, 0x00]), "Length = 3"
        assert data[4:7] == b'Hi\x00', "String + NUL"
        assert len(data) == 7, "No trailing padding"

    def test_alignment_padding(self):
        """CDR alignment adds correct padding."""
        ser = CdrSerializer()
        ser.write_uint8(0xAA)
        ser.write_uint32(0x12345678)
        data = ser.getvalue()
        # u8 (1 byte) + padding (3 bytes) + u32 (4 bytes) = 8 bytes
        assert len(data) == 8
        assert data[0] == 0xAA
        assert data[1:4] == bytes([0, 0, 0]), "Padding bytes"
        assert data[4:8] == bytes([0x78, 0x56, 0x34, 0x12]), "u32 LE"


class TestLocatorBytes:
    """Test Locator serialization format."""

    def test_ipv4_locator_format(self):
        """IPv4 locator uses bytes 12-15 for address."""
        loc = Locator.from_ipv4("192.168.1.100", 7400)
        data = loc.to_bytes()

        assert len(data) == 24, "Locator is 24 bytes"
        # Kind (4) + Port (4) + Address (16)
        assert data[0:4] == bytes([1, 0, 0, 0]), "LOCATOR_KIND_UDPv4 = 1"
        assert data[4:8] == bytes([0xE8, 0x1C, 0x00, 0x00]), "Port 7400 LE"
        # IPv4 in bytes 12-15 of the 16-byte address field
        assert data[8:20] == bytes([0] * 12), "First 12 bytes zero"
        assert data[20:24] == bytes([192, 168, 1, 100]), "IPv4 address"


class TestGuidBytes:
    """Test GUID serialization format."""

    def test_guid_format(self):
        """GUID is 16 bytes: prefix (12) + entity_id (4)."""
        prefix = GuidPrefix(bytes(range(12)))
        entity = EntityId(bytes([0xAA, 0xBB, 0xCC, 0xDD]))
        guid = Guid(prefix, entity)

        data = guid.to_bytes()
        assert len(data) == 16
        assert data[:12] == bytes(range(12)), "Prefix"
        assert data[12:16] == bytes([0xAA, 0xBB, 0xCC, 0xDD]), "Entity ID"


class TestSequenceNumberBytes:
    """Test SequenceNumber serialization format."""

    def test_sequence_number_format(self):
        """SequenceNumber is 8 bytes: high (4) + low (4)."""
        sn = SequenceNumber.from_value(0x100000001)  # high=1, low=1

        ser = CdrSerializer()
        sn.serialize(ser)
        data = ser.getvalue()

        assert len(data) == 8
        # High (i32) in LE
        assert data[0:4] == bytes([0x01, 0x00, 0x00, 0x00]), "High = 1"
        # Low (u32) in LE
        assert data[4:8] == bytes([0x01, 0x00, 0x00, 0x00]), "Low = 1"


# Cross-language byte export for Rust tests
PYTHON_SPDP_BYTES = None
PYTHON_SEDP_BYTES = None

def generate_test_bytes():
    """Generate bytes that Rust tests can use."""
    global PYTHON_SPDP_BYTES, PYTHON_SEDP_BYTES

    # SPDP
    prefix = GuidPrefix(bytes([0xAA, 0xBB, 0xCC, 0xDD, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]))
    writer = SPDPWriter(
        guid_prefix=prefix,
        local_ip="192.168.1.100",
        metatraffic_unicast_port=7410,
        user_unicast_port=7401,
    )
    PYTHON_SPDP_BYTES = writer.build_announcement()

    # SEDP
    endpoint_guid = Guid(prefix, EntityId(bytes([0x00, 0x00, 0x01, 0x02])))
    pl = ParameterListBuilder()
    pl.add_parameter(PID_ENDPOINT_GUID, endpoint_guid.to_bytes())
    ser = CdrSerializer()
    ser.write_string("HelloWorld")
    pl.add_parameter(PID_TOPIC_NAME, ser.getvalue())
    ser = CdrSerializer()
    ser.write_string("HelloWorld::HelloWorld")
    pl.add_parameter(PID_TYPE_NAME, ser.getvalue())
    qos = QosPolicy(reliability=ReliabilityKind.RELIABLE)
    pl.add_parameter(PID_RELIABILITY, serialize_reliability_qos(qos))
    pl.add_parameter(PID_DURABILITY, serialize_durability_qos(qos))
    payload = encapsulation_header(PL_CDR_LE) + pl.finalize()

    builder = RtpsMessageBuilder(prefix)
    builder.add_info_ts(Timestamp.from_seconds(1000.0))
    builder.add_data(
        reader_id=EntityId(bytes([0x00, 0x00, 0x03, 0xC7])),
        writer_id=EntityId(bytes([0x00, 0x00, 0x03, 0xC2])),
        writer_sn=SequenceNumber.from_value(1),
        serialized_payload=payload,
    )
    PYTHON_SEDP_BYTES = builder.build()

    return PYTHON_SPDP_BYTES, PYTHON_SEDP_BYTES


# ==============================================================================
# Rust-generated bytes for Python to parse (cross-language compatibility)
# Generated by: cargo run --example export_test_bytes
# ==============================================================================

# SPDP bytes generated by Rust
# GuidPrefix: 0xDEADBEEF01020304 05060708
# IP: 10.0.0.50, metatraffic_port=7410, user_port=7401
RUST_SPDP_BYTES = bytes([
    0x52, 0x54, 0x50, 0x53, 0x02, 0x05, 0xff, 0x01, 0xde, 0xad, 0xbe, 0xef,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x01, 0x08, 0x00,
    0x4e, 0xd2, 0x7a, 0x69, 0x00, 0x80, 0x14, 0x21, 0x15, 0x05, 0x8c, 0x00,
    0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc2,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x15, 0x00, 0x04, 0x00, 0x02, 0x05, 0x00, 0x00, 0x16, 0x00, 0x04, 0x00,
    0xff, 0x01, 0x00, 0x00, 0x50, 0x00, 0x10, 0x00, 0xde, 0xad, 0xbe, 0xef,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x01, 0xc1,
    0x02, 0x00, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x31, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe9, 0x1c, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0a, 0x00, 0x00, 0x32, 0x32, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xf2, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x32, 0x58, 0x00, 0x04, 0x00,
    0x3f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
])

# SEDP message bytes generated by Rust
# Contains: INFO_TS + INFO_DST + DATA with endpoint info
# Topic: "TestTopic", Type: "TestType", Reliability: RELIABLE
RUST_SEDP_BYTES = bytes([
    0x52, 0x54, 0x50, 0x53, 0x02, 0x05, 0xff, 0x01, 0xde, 0xad, 0xbe, 0xef,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x01, 0x08, 0x00,
    0xe8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x01, 0x0c, 0x00,
    0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
    0x15, 0x05, 0x70, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0xc7,
    0x00, 0x00, 0x03, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x03, 0x00, 0x00, 0x5a, 0x00, 0x10, 0x00, 0xde, 0xad, 0xbe, 0xef,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x01, 0x02,
    0x05, 0x00, 0x10, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x54, 0x65, 0x73, 0x74,
    0x54, 0x6f, 0x70, 0x69, 0x63, 0x00, 0x00, 0x00, 0x07, 0x00, 0x10, 0x00,
    0x09, 0x00, 0x00, 0x00, 0x54, 0x65, 0x73, 0x74, 0x54, 0x79, 0x70, 0x65,
    0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x0c, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
])

# HEARTBEAT bytes generated by Rust
RUST_HEARTBEAT_BYTES = bytes([
    0x52, 0x54, 0x50, 0x53, 0x02, 0x05, 0xff, 0x01, 0xde, 0xad, 0xbe, 0xef,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x07, 0x01, 0x1c, 0x00,
    0x00, 0x00, 0x03, 0xc7, 0x00, 0x00, 0x03, 0xc2, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00,
])


class TestParseRustBytes:
    """Test that Python can parse bytes generated by Rust."""

    def test_parse_rust_spdp_header(self):
        """Parse Rust-generated SPDP header."""
        from vibedds.wire import RtpsMessageParser

        msg = RtpsMessageParser.parse(RUST_SPDP_BYTES)

        # Verify RTPS header
        assert msg.header.version.major == 2
        assert msg.header.version.minor == 5
        assert msg.header.vendor_id.vendor == (0xFF, 0x01)

        # Verify GUID prefix
        expected_prefix = bytes([0xDE, 0xAD, 0xBE, 0xEF, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08])
        assert msg.header.guid_prefix.value == expected_prefix

    def test_parse_rust_spdp_full(self):
        """Parse full Rust-generated SPDP announcement."""
        from vibedds.spdp import SPDPReader

        participant = SPDPReader.parse_announcement(RUST_SPDP_BYTES)
        assert participant is not None

        # Verify GUID prefix
        expected_prefix = bytes([0xDE, 0xAD, 0xBE, 0xEF, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08])
        assert participant.guid_prefix.value == expected_prefix

        # Verify protocol version and vendor
        assert participant.protocol_version.major == 2
        assert participant.protocol_version.minor == 5
        assert participant.vendor_id.vendor == (0xFF, 0x01)

        # Verify lease duration (100 seconds)
        assert participant.lease_duration is not None
        assert participant.lease_duration.seconds == 100

        # Verify locators
        assert len(participant.default_unicast_locators) > 0
        assert participant.default_unicast_locators[0].port == 7401

        assert len(participant.metatraffic_unicast_locators) > 0
        assert participant.metatraffic_unicast_locators[0].port == 7410

        # Verify IP (10.0.0.50 in locator bytes 12-15)
        loc = participant.default_unicast_locators[0]
        assert loc.address[12:16] == bytes([10, 0, 0, 50])

    def test_parse_rust_sedp_header(self):
        """Parse Rust-generated SEDP message header."""
        from vibedds.wire import RtpsMessageParser

        msg = RtpsMessageParser.parse(RUST_SEDP_BYTES)

        # Verify RTPS header
        assert msg.header.version.major == 2
        assert msg.header.version.minor == 5

        # Should have INFO_TS + INFO_DST + DATA
        assert len(msg.submessages) >= 2

    def test_parse_rust_sedp_endpoint_data(self):
        """Parse Rust-generated SEDP endpoint data."""
        from vibedds.wire import RtpsMessageParser
        from vibedds.messages import DataSubmessage
        from vibedds.cdr import ParameterListParser

        msg = RtpsMessageParser.parse(RUST_SEDP_BYTES)

        # Find DATA submessage
        data_sm = None
        for sm in msg.submessages:
            if isinstance(sm, DataSubmessage):
                data_sm = sm
                break

        assert data_sm is not None, "Should have DATA submessage"

        # Verify it's from SEDP publications writer
        assert data_sm.writer_id.value == bytes([0x00, 0x00, 0x03, 0xC2])
        assert data_sm.reader_id.value == bytes([0x00, 0x00, 0x03, 0xC7])

        # Parse the payload
        payload = data_sm.serialized_payload
        assert payload is not None

        # Skip encapsulation header (4 bytes)
        pl_data = payload[4:]

        # Parse parameter list
        found_guid = False
        found_topic = False
        found_type = False
        found_reliability = False

        for pid, value in ParameterListParser(pl_data):
            if pid == PID_ENDPOINT_GUID:
                # 16 bytes GUID
                assert len(value) == 16
                guid_prefix = value[:12]
                expected = bytes([0xDE, 0xAD, 0xBE, 0xEF, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08])
                assert guid_prefix == expected
                found_guid = True
            elif pid == PID_TOPIC_NAME:
                # CDR string
                length = int.from_bytes(value[:4], 'little')
                topic = value[4:4+length-1].decode('utf-8')
                assert topic == "TestTopic"
                found_topic = True
            elif pid == PID_TYPE_NAME:
                length = int.from_bytes(value[:4], 'little')
                type_name = value[4:4+length-1].decode('utf-8')
                assert type_name == "TestType"
                found_type = True
            elif pid == PID_RELIABILITY:
                kind = int.from_bytes(value[:4], 'little')
                assert kind == 2, "Should be RELIABLE (2)"
                found_reliability = True

        assert found_guid, "Should find PID_ENDPOINT_GUID"
        assert found_topic, "Should find PID_TOPIC_NAME"
        assert found_type, "Should find PID_TYPE_NAME"
        assert found_reliability, "Should find PID_RELIABILITY"

    def test_parse_rust_heartbeat(self):
        """Parse Rust-generated HEARTBEAT message."""
        from vibedds.wire import RtpsMessageParser
        from vibedds.messages import HeartbeatSubmessage

        msg = RtpsMessageParser.parse(RUST_HEARTBEAT_BYTES)

        # Verify header
        assert msg.header.version.major == 2

        # Find HEARTBEAT submessage
        hb = None
        for sm in msg.submessages:
            if isinstance(sm, HeartbeatSubmessage):
                hb = sm
                break

        assert hb is not None, "Should have HEARTBEAT submessage"

        # Verify HEARTBEAT fields
        assert hb.writer_id.value == bytes([0x00, 0x00, 0x03, 0xC2])
        assert hb.reader_id.value == bytes([0x00, 0x00, 0x03, 0xC7])
        assert hb.first_sn.value == 1
        assert hb.last_sn.value == 10
        assert hb.count == 5


if __name__ == "__main__":
    # Generate and print bytes for manual verification or Rust test embedding
    spdp, sedp = generate_test_bytes()
    print("SPDP bytes ({} bytes):".format(len(spdp)))
    print("    " + ", ".join(f"0x{b:02x}" for b in spdp[:40]) + ", ...")
    print()
    print("SEDP bytes ({} bytes):".format(len(sedp)))
    print("    " + ", ".join(f"0x{b:02x}" for b in sedp[:40]) + ", ...")
