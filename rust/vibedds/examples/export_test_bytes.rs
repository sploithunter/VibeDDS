/// Export known test bytes for Python wire compatibility tests.
///
/// Run with: cargo run --example export_test_bytes
/// Then copy the output into Python test_wire_compat.py

use vibedds::cdr::{encapsulation_header, Endian, ParameterListBuilder, CdrSerializer};
use vibedds::constants::*;
use vibedds::spdp::SpdpWriter;
use vibedds::types::*;
use vibedds::wire::RtpsMessageBuilder;

fn main() {
    // Use deterministic values for reproducibility
    let prefix = GuidPrefix([
        0xDE, 0xAD, 0xBE, 0xEF, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    ]);
    let local_ip: std::net::Ipv4Addr = "10.0.0.50".parse().unwrap();

    // Generate SPDP bytes
    println!("=== Rust-generated SPDP bytes ===");
    let mut spdp_writer = SpdpWriter::new(prefix, local_ip, 7410, 7401);
    let spdp_bytes = spdp_writer.build_announcement();
    println!("SPDP bytes ({} bytes):", spdp_bytes.len());
    print_bytes(&spdp_bytes);

    // Generate SEDP endpoint data bytes
    println!("\n=== Rust-generated SEDP endpoint data ===");
    let sedp_bytes = generate_sedp_endpoint_data(prefix);
    println!("SEDP endpoint data ({} bytes):", sedp_bytes.len());
    print_bytes(&sedp_bytes);

    // Generate complete SEDP message
    println!("\n=== Rust-generated SEDP message ===");
    let sedp_msg = generate_sedp_message(prefix);
    println!("SEDP message ({} bytes):", sedp_msg.len());
    print_bytes(&sedp_msg);

    // Generate HEARTBEAT message
    println!("\n=== Rust-generated HEARTBEAT ===");
    let hb_bytes = generate_heartbeat(prefix);
    println!("HEARTBEAT ({} bytes):", hb_bytes.len());
    print_bytes(&hb_bytes);

    // Generate Locator bytes
    println!("\n=== Rust-generated Locator (10.0.0.50:7400) ===");
    let loc = Locator::from_ipv4("10.0.0.50", 7400);
    let loc_bytes = loc.to_bytes();
    println!("Locator ({} bytes):", loc_bytes.len());
    print_bytes(&loc_bytes);

    // Print Python embedding format
    println!("\n\n=== Python format for embedding ===");
    println!("\n# SPDP bytes generated by Rust");
    println!("RUST_SPDP_BYTES = bytes([");
    print_python_bytes(&spdp_bytes);
    println!("])");

    println!("\n# SEDP message bytes generated by Rust");
    println!("RUST_SEDP_BYTES = bytes([");
    print_python_bytes(&sedp_msg);
    println!("])");

    println!("\n# HEARTBEAT bytes generated by Rust");
    println!("RUST_HEARTBEAT_BYTES = bytes([");
    print_python_bytes(&hb_bytes);
    println!("])");
}

fn generate_sedp_endpoint_data(prefix: GuidPrefix) -> Vec<u8> {
    let endpoint_guid = Guid {
        prefix,
        entity_id: EntityId([0x00, 0x00, 0x01, 0x02]), // user writer
    };

    let mut pl = ParameterListBuilder::new(Endian::Little);

    // PID_ENDPOINT_GUID
    pl.add_parameter(PID_ENDPOINT_GUID, &endpoint_guid.to_bytes());

    // PID_TOPIC_NAME
    let mut ser = CdrSerializer::new(Endian::Little);
    ser.write_string("TestTopic");
    pl.add_parameter(PID_TOPIC_NAME, ser.buffer());

    // PID_TYPE_NAME
    let mut ser = CdrSerializer::new(Endian::Little);
    ser.write_string("TestType");
    pl.add_parameter(PID_TYPE_NAME, ser.buffer());

    // PID_RELIABILITY (RELIABLE = 2)
    let mut ser = CdrSerializer::new(Endian::Little);
    ser.write_u32(2); // RELIABLE
    ser.write_i32(0); // max_blocking_time.seconds
    ser.write_u32(0); // max_blocking_time.fraction
    pl.add_parameter(PID_RELIABILITY, ser.buffer());

    // PID_DURABILITY (VOLATILE = 0)
    let mut ser = CdrSerializer::new(Endian::Little);
    ser.write_u32(0);
    pl.add_parameter(PID_DURABILITY, ser.buffer());

    let mut result = encapsulation_header(PL_CDR_LE).to_vec();
    result.extend(pl.finalize());
    result
}

fn generate_sedp_message(prefix: GuidPrefix) -> Vec<u8> {
    let dest_prefix = GuidPrefix([0xCC; 12]); // dummy destination
    let payload = generate_sedp_endpoint_data(prefix);

    let mut builder = RtpsMessageBuilder::new(prefix);
    builder.add_info_ts(Some(Timestamp { seconds: 1000, fraction: 0 }));
    builder.add_info_dst(dest_prefix);
    builder.add_data(
        EntityId(ENTITYID_SEDP_BUILTIN_PUBLICATIONS_READER),
        EntityId(ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER),
        SequenceNumber::from_value(1),
        Some(&payload),
        None, // inline_qos
        false, // key_payload
    );

    builder.build()
}

fn generate_heartbeat(prefix: GuidPrefix) -> Vec<u8> {
    let mut builder = RtpsMessageBuilder::new(prefix);
    builder.add_heartbeat(
        EntityId(ENTITYID_SEDP_BUILTIN_PUBLICATIONS_READER),
        EntityId(ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER),
        SequenceNumber::from_value(1),
        SequenceNumber::from_value(10),
        5,
        false, // final_flag
        false, // liveliness
    );
    builder.build()
}

fn print_bytes(bytes: &[u8]) {
    for (i, chunk) in bytes.chunks(16).enumerate() {
        print!("  {:04x}: ", i * 16);
        for b in chunk {
            print!("{:02x} ", b);
        }
        println!();
    }
}

fn print_python_bytes(bytes: &[u8]) {
    for (i, chunk) in bytes.chunks(12).enumerate() {
        print!("    ");
        for (j, b) in chunk.iter().enumerate() {
            print!("0x{:02x}", b);
            if i * 12 + j < bytes.len() - 1 {
                print!(", ");
            }
        }
        println!();
    }
}
