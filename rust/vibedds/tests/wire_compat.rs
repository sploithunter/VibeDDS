/// Wire compatibility tests - verify Rust can parse Python-generated bytes.
///
/// These tests ensure that bytes serialized by Python VibeDDS can be
/// correctly parsed by Rust VibeDDS, and vice versa.

use vibedds::cdr::{parse_encapsulation_header, Endian, ParameterListParser};
use vibedds::constants::*;
use vibedds::messages::Submessage;
use vibedds::spdp::SpdpReader;
use vibedds::types::*;
use vibedds::wire::parse_rtps_message;

// Python-generated SPDP bytes (from test_wire_compat.py)
const PYTHON_SPDP_BYTES: &[u8] = &[
    0x52, 0x54, 0x50, 0x53, 0x02, 0x05, 0xff, 0x01, 0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x06, 0x07, 0x08, 0x09, 0x01, 0x08, 0x00, 0xf8, 0xd0, 0x7a, 0x69, 0x00, 0xf0, 0x7f, 0x13,
    0x15, 0x05, 0x8c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc2,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00,
    0x02, 0x05, 0x00, 0x00, 0x16, 0x00, 0x04, 0x00, 0xff, 0x01, 0x00, 0x00, 0x50, 0x00, 0x10, 0x00,
    0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x01, 0xc1,
    0x02, 0x00, 0x08, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x18, 0x00,
    0x01, 0x00, 0x00, 0x00, 0xe9, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xc0, 0xa8, 0x01, 0x64, 0x32, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xf2, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xc0, 0xa8, 0x01, 0x64, 0x58, 0x00, 0x04, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
];

// Python-generated SEDP bytes
const PYTHON_SEDP_BYTES: &[u8] = &[
    0x52, 0x54, 0x50, 0x53, 0x02, 0x05, 0xff, 0x01, 0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x06, 0x07, 0x08, 0x09, 0x01, 0x08, 0x00, 0xe8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x15, 0x05, 0x7c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0xc7, 0x00, 0x00, 0x03, 0xc2,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x5a, 0x00, 0x10, 0x00,
    0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x01, 0x02,
    0x05, 0x00, 0x10, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x57, 0x6f, 0x72,
    0x6c, 0x64, 0x00, 0x00, 0x07, 0x00, 0x1c, 0x00, 0x17, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c,
    0x6f, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x3a, 0x3a, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x57, 0x6f, 0x72,
    0x6c, 0x64, 0x00, 0x00, 0x1a, 0x00, 0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
];

#[test]
fn test_parse_python_spdp_header() {
    let msg = parse_rtps_message(PYTHON_SPDP_BYTES).expect("Failed to parse SPDP message");

    // Verify RTPS header
    assert_eq!(msg.header.version, ProtocolVersion::new(2, 5));
    assert_eq!(msg.header.vendor_id, VendorId([0xFF, 0x01]));

    let expected_prefix = GuidPrefix([
        0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    ]);
    assert_eq!(msg.header.guid_prefix, expected_prefix);
}

#[test]
fn test_parse_python_spdp_submessages() {
    let msg = parse_rtps_message(PYTHON_SPDP_BYTES).expect("Failed to parse SPDP message");

    // Should have INFO_TS + DATA
    assert!(msg.submessages.len() >= 2, "Expected at least 2 submessages");

    // First should be INFO_TS
    assert!(
        matches!(&msg.submessages[0], Submessage::InfoTimestamp(_)),
        "First submessage should be InfoTimestamp"
    );

    // Second should be DATA
    assert!(
        matches!(&msg.submessages[1], Submessage::Data(_)),
        "Second submessage should be Data"
    );
}

#[test]
fn test_parse_python_spdp_full() {
    let participant =
        SpdpReader::parse_announcement(PYTHON_SPDP_BYTES).expect("Failed to parse SPDP");

    // Verify parsed participant data
    let expected_prefix = GuidPrefix([
        0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    ]);
    assert_eq!(participant.guid_prefix, expected_prefix);

    assert_eq!(
        participant.protocol_version,
        Some(ProtocolVersion::new(2, 5))
    );
    assert_eq!(participant.vendor_id, Some(VendorId([0xFF, 0x01])));

    // Verify lease duration (100 seconds)
    assert!(participant.lease_duration.is_some());
    assert_eq!(participant.lease_duration.unwrap().seconds, 100);

    // Verify locators
    assert!(!participant.default_unicast_locators.is_empty());
    assert_eq!(participant.default_unicast_locators[0].port, 7401);

    assert!(!participant.metatraffic_unicast_locators.is_empty());
    assert_eq!(participant.metatraffic_unicast_locators[0].port, 7410);

    // Verify IP address (192.168.1.100)
    let loc = &participant.default_unicast_locators[0];
    assert_eq!(loc.address[12..16], [192, 168, 1, 100]);
}

#[test]
fn test_parse_python_sedp_header() {
    let msg = parse_rtps_message(PYTHON_SEDP_BYTES).expect("Failed to parse SEDP message");

    // Verify RTPS header
    assert_eq!(msg.header.version, ProtocolVersion::new(2, 5));
    assert_eq!(msg.header.vendor_id, VendorId([0xFF, 0x01]));
}

#[test]
fn test_parse_python_sedp_data_submessage() {
    let msg = parse_rtps_message(PYTHON_SEDP_BYTES).expect("Failed to parse SEDP message");

    // Find DATA submessage
    let data_sm = msg
        .submessages
        .iter()
        .find_map(|sm| {
            if let Submessage::Data(d) = sm {
                Some(d)
            } else {
                None
            }
        })
        .expect("No DATA submessage found");

    // Verify it's from SEDP publications writer
    assert_eq!(data_sm.writer_id.0, ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER);
    assert_eq!(data_sm.reader_id.0, ENTITYID_SEDP_BUILTIN_PUBLICATIONS_READER);

    // Verify sequence number
    assert_eq!(data_sm.writer_sn.value(), 1);

    // Verify payload exists
    assert!(data_sm.serialized_payload.is_some());
}

#[test]
fn test_parse_python_sedp_endpoint_data() {
    let msg = parse_rtps_message(PYTHON_SEDP_BYTES).expect("Failed to parse SEDP message");

    let data_sm = msg
        .submessages
        .iter()
        .find_map(|sm| {
            if let Submessage::Data(d) = sm {
                Some(d)
            } else {
                None
            }
        })
        .expect("No DATA submessage");

    let payload = data_sm.serialized_payload.as_ref().unwrap();

    // Parse encapsulation header
    let (scheme, offset) = parse_encapsulation_header(payload).expect("Failed to parse encapsulation");
    assert_eq!(scheme, PL_CDR_LE, "Should be PL_CDR_LE");

    // Parse parameter list
    let pl_data = &payload[offset..];
    let mut found_guid = false;
    let mut found_topic = false;
    let mut found_type = false;
    let mut found_reliability = false;

    for (pid, value) in ParameterListParser::new(pl_data, Endian::Little) {
        match pid {
            PID_ENDPOINT_GUID => {
                assert_eq!(value.len(), 16);
                let guid = Guid::from_bytes(value);
                let expected_prefix = GuidPrefix([
                    0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                ]);
                assert_eq!(guid.prefix, expected_prefix);
                assert_eq!(guid.entity_id.0, [0x00, 0x00, 0x01, 0x02]);
                found_guid = true;
            }
            PID_TOPIC_NAME => {
                // CDR string: length (u32) + chars + NUL
                let len = u32::from_le_bytes([value[0], value[1], value[2], value[3]]) as usize;
                let topic = std::str::from_utf8(&value[4..4 + len - 1]).unwrap();
                assert_eq!(topic, "HelloWorld");
                found_topic = true;
            }
            PID_TYPE_NAME => {
                let len = u32::from_le_bytes([value[0], value[1], value[2], value[3]]) as usize;
                let type_name = std::str::from_utf8(&value[4..4 + len - 1]).unwrap();
                assert_eq!(type_name, "HelloWorld::HelloWorld");
                found_type = true;
            }
            PID_RELIABILITY => {
                // Reliability kind (u32) + max_blocking_time (Duration: i32 + u32)
                let kind = u32::from_le_bytes([value[0], value[1], value[2], value[3]]);
                assert_eq!(kind, 2, "Should be RELIABLE (2)");
                found_reliability = true;
            }
            _ => {}
        }
    }

    assert!(found_guid, "Should find PID_ENDPOINT_GUID");
    assert!(found_topic, "Should find PID_TOPIC_NAME");
    assert!(found_type, "Should find PID_TYPE_NAME");
    assert!(found_reliability, "Should find PID_RELIABILITY");
}

#[test]
fn test_locator_byte_format() {
    // Known IPv4 locator bytes (from Python)
    let locator_bytes: [u8; 24] = [
        0x01, 0x00, 0x00, 0x00, // kind = 1 (UDPv4)
        0xe8, 0x1c, 0x00, 0x00, // port = 7400 (0x1CE8)
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // address[0..8]
        0x00, 0x00, 0x00, 0x00, // address[8..12]
        0xc0, 0xa8, 0x01, 0x64, // address[12..16] = 192.168.1.100
    ];

    let loc = Locator::from_bytes(&locator_bytes);
    assert_eq!(loc.kind, LOCATOR_KIND_UDPV4);
    assert_eq!(loc.port, 7400);
    assert_eq!(loc.ipv4_str().unwrap(), "192.168.1.100");
}

#[test]
fn test_guid_byte_format() {
    // Known GUID bytes
    let guid_bytes: [u8; 16] = [
        0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02, 0x03, 0x04, // prefix[0..8]
        0x05, 0x06, 0x07, 0x08, // prefix[8..12]
        0x00, 0x00, 0x01, 0xc1, // entity_id (participant)
    ];

    let guid = Guid::from_bytes(&guid_bytes);
    assert_eq!(
        guid.prefix.0,
        [0xaa, 0xbb, 0xcc, 0xdd, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]
    );
    assert_eq!(guid.entity_id.0, ENTITYID_PARTICIPANT);
}

#[test]
fn test_sequence_number_byte_format() {
    use vibedds::cdr::{CdrDeserializer, CdrSerializer, Endian};

    // Test serialization
    let sn = SequenceNumber::from_value(0x100000005); // high=1, low=5
    let mut ser = CdrSerializer::new(Endian::Little);
    sn.serialize(&mut ser);
    let bytes = ser.buffer();

    assert_eq!(bytes.len(), 8);
    assert_eq!(bytes[0..4], [0x01, 0x00, 0x00, 0x00]); // high = 1
    assert_eq!(bytes[4..8], [0x05, 0x00, 0x00, 0x00]); // low = 5

    // Test deserialization
    let mut de = CdrDeserializer::new(bytes, Endian::Little);
    let parsed = SequenceNumber::deserialize(&mut de).unwrap();
    assert_eq!(parsed.value(), 0x100000005);
}

#[test]
fn test_timestamp_byte_format() {
    use vibedds::cdr::{CdrDeserializer, CdrSerializer, Endian};

    let ts = Timestamp {
        seconds: 1000,
        fraction: 0x80000000, // 0.5 seconds
    };

    let mut ser = CdrSerializer::new(Endian::Little);
    ts.serialize(&mut ser);
    let bytes = ser.buffer();

    assert_eq!(bytes.len(), 8);
    // seconds = 1000 = 0x3E8
    assert_eq!(bytes[0..4], [0xe8, 0x03, 0x00, 0x00]);
    // fraction = 0x80000000
    assert_eq!(bytes[4..8], [0x00, 0x00, 0x00, 0x80]);

    // Roundtrip
    let mut de = CdrDeserializer::new(bytes, Endian::Little);
    let parsed = Timestamp::deserialize(&mut de).unwrap();
    assert_eq!(parsed.seconds, 1000);
    assert_eq!(parsed.fraction, 0x80000000);
}

#[test]
fn test_duration_byte_format() {
    // INFINITE duration
    let inf = Duration::INFINITE;
    let bytes = inf.to_bytes_le();

    assert_eq!(bytes.len(), 8);
    assert_eq!(bytes[0..4], [0xff, 0xff, 0xff, 0x7f]); // 0x7FFFFFFF
    assert_eq!(bytes[4..8], [0xff, 0xff, 0xff, 0xff]); // 0xFFFFFFFF
}

// ============================================================================
// DATA Submessage wire compatibility tests
// ============================================================================

use vibedds::wire::RtpsMessageBuilder;
use vibedds::type_support::HelloWorldType;
use vibedds::endpoint::DataWriter;

#[test]
fn test_rust_data_message_structure() {
    // Build a DATA message using RtpsMessageBuilder
    let prefix = GuidPrefix([0xAA; 12]);
    let writer_id = EntityId([0x00, 0x00, 0x01, 0x02]); // user writer
    let reader_id = EntityId(ENTITYID_UNKNOWN);
    let sn = SequenceNumber::from_value(1);
    let payload = HelloWorldType::serialize("Hello");

    let mut builder = RtpsMessageBuilder::new(prefix);
    builder.add_data(reader_id, writer_id, sn, Some(&payload), None, false);
    let msg_bytes = builder.build();

    // Verify we can parse it back
    let parsed = parse_rtps_message(&msg_bytes).expect("Failed to parse");
    assert_eq!(parsed.header.guid_prefix, prefix);
    assert_eq!(parsed.submessages.len(), 1);

    if let Submessage::Data(data_sm) = &parsed.submessages[0] {
        assert_eq!(data_sm.writer_id, writer_id);
        assert_eq!(data_sm.reader_id.0, ENTITYID_UNKNOWN);
        assert_eq!(data_sm.writer_sn.value(), 1);

        // Verify payload
        let pl = data_sm.serialized_payload.as_ref().expect("No payload");
        let decoded = HelloWorldType::deserialize(pl).expect("Failed to decode");
        assert_eq!(decoded, "Hello");
    } else {
        panic!("Expected Data submessage");
    }
}

#[test]
fn test_rust_datawriter_produces_valid_rtps() {
    // Use DataWriter to produce a message and verify structure
    let prefix = GuidPrefix([0xBB; 12]);
    let entity_id = EntityId([0x00, 0x00, 0x01, 0x02]);
    let guid = Guid::new(prefix, entity_id);

    let mut writer = DataWriter::new(
        guid,
        "TestTopic".to_string(),
        "TestType".to_string(),
        false, // best-effort
    );

    let payload = HelloWorldType::serialize("Test Message");
    let msg_bytes = writer.write(&payload);

    // Verify RTPS header
    assert_eq!(&msg_bytes[0..4], b"RTPS");
    assert_eq!(msg_bytes[4], 2); // version major
    assert_eq!(msg_bytes[5], 5); // version minor
    assert_eq!(msg_bytes[6], VENDOR_ID[0]);
    assert_eq!(msg_bytes[7], VENDOR_ID[1]);

    // Parse the message
    let parsed = parse_rtps_message(&msg_bytes).expect("Failed to parse writer output");
    assert_eq!(parsed.header.guid_prefix, prefix);

    // Should have INFO_TS + DATA
    assert!(parsed.submessages.len() >= 2);

    // Find DATA submessage
    let data_sm = parsed.submessages.iter().find_map(|sm| {
        if let Submessage::Data(d) = sm { Some(d) } else { None }
    }).expect("No DATA submessage");

    assert_eq!(data_sm.writer_id, entity_id);
    assert_eq!(data_sm.writer_sn.value(), 1);

    // Decode payload
    let pl = data_sm.serialized_payload.as_ref().unwrap();
    let decoded = HelloWorldType::deserialize(pl).unwrap();
    assert_eq!(decoded, "Test Message");
}

#[test]
fn test_hello_world_cdr_wire_format() {
    // Test the CDR encoding of HelloWorld matches expected format
    let payload = HelloWorldType::serialize("Hi");

    // Expected format:
    // [0..4]: Encapsulation header (00 01 00 00 for CDR_LE)
    // [4..8]: String length including NUL (3 = 03 00 00 00 LE)
    // [8..11]: "Hi\0"

    assert_eq!(payload[0..4], [0x00, 0x01, 0x00, 0x00]); // CDR_LE
    assert_eq!(payload[4..8], [0x03, 0x00, 0x00, 0x00]); // length=3
    assert_eq!(payload[8..11], [0x48, 0x69, 0x00]); // "Hi\0"
}

#[test]
fn test_shape_type_cdr_wire_format() {
    use vibedds::type_support::ShapeType;

    let payload = ShapeType::serialize("RED", 50, 75, 25);

    // Verify encapsulation header
    assert_eq!(payload[0..4], [0x00, 0x01, 0x00, 0x00]); // CDR_LE

    // Roundtrip test
    let shape = ShapeType::deserialize(&payload).unwrap();
    assert_eq!(shape.color, "RED");
    assert_eq!(shape.x, 50);
    assert_eq!(shape.y, 75);
    assert_eq!(shape.shapesize, 25);
}

#[test]
fn test_data_submessage_with_info_dst() {
    // Test message with INFO_DST + DATA (for unicast)
    let src_prefix = GuidPrefix([0xAA; 12]);
    let dst_prefix = GuidPrefix([0xBB; 12]);
    let writer_id = EntityId([0x00, 0x00, 0x01, 0x02]);
    let reader_id = EntityId([0x00, 0x00, 0x01, 0x07]);
    let sn = SequenceNumber::from_value(5);
    let payload = HelloWorldType::serialize("Directed");

    let mut builder = RtpsMessageBuilder::new(src_prefix);
    builder.add_info_dst(dst_prefix);
    builder.add_data(reader_id, writer_id, sn, Some(&payload), None, false);
    let msg_bytes = builder.build();

    // Parse and verify
    let parsed = parse_rtps_message(&msg_bytes).unwrap();
    assert_eq!(parsed.submessages.len(), 2);

    // First should be INFO_DST
    if let Submessage::InfoDestination(info_dst) = &parsed.submessages[0] {
        assert_eq!(info_dst.guid_prefix, dst_prefix);
    } else {
        panic!("Expected InfoDestination");
    }

    // Second should be DATA
    if let Submessage::Data(data_sm) = &parsed.submessages[1] {
        assert_eq!(data_sm.reader_id, reader_id);
        assert_eq!(data_sm.writer_sn.value(), 5);
    } else {
        panic!("Expected Data");
    }
}

#[test]
fn test_multiple_data_sequence_numbers() {
    // Test that DataWriter increments sequence numbers
    let guid = Guid::new(
        GuidPrefix([0xCC; 12]),
        EntityId([0x00, 0x00, 0x01, 0x02]),
    );

    let mut writer = DataWriter::new(
        guid,
        "TestTopic".to_string(),
        "TestType".to_string(),
        false,
    );

    for i in 1..=5 {
        let payload = HelloWorldType::serialize(&format!("Message {}", i));
        let msg_bytes = writer.write(&payload);

        let parsed = parse_rtps_message(&msg_bytes).unwrap();
        let data_sm = parsed.submessages.iter().find_map(|sm| {
            if let Submessage::Data(d) = sm { Some(d) } else { None }
        }).unwrap();

        assert_eq!(data_sm.writer_sn.value(), i as i64, "Sequence number mismatch");
    }
}
